// 与えられたドット絵の周長を計算する
// 飛び地や池のあるドット絵の周長も計算する

// 周長とは、ドット絵の白マスと黒マスの境界線をすべて辿る最短の閉路の長さ
// 飛び地や池のあるドット絵の場合、白マス同志の境界線や黒マス同志の境界線を通ることも可
// ただし、そのような辺は往復しなければならない

// 言い換えると、島と島を結ぶ橋のような役割

// 大まかなアルゴリズム
// ドット絵の外側にある辺を選択肢から取り除く
// ドット絵の色マスの境界にある辺をすべて辺集合Sに入れる
// 選択肢を幅優先探索で選び、最初に見つかった閉路の長さを返す

// もうちょっと厳密な数学的な表現をしたい

// 各要素が0または1からなる8行8列の行列をドット絵行列と呼ぶ
// 4点(i,j), (i+1,j), (i+1,j+1), (i,j+1) を結んでできる正方形をドットと呼ぶ
// ドット絵行列の各要素 A(i,j) はドット (i,j) の色を表す
// 0は白、1は黒である
// (0,0)から(7,7)までのドットによって作られるパターンをドット絵と呼ぶ
// (-1,-1)から(8,8)までのドットによって作られるパターンを拡張ドット絵と呼ぶ
// ただし、(0,0)から(7,7)の範囲にないドットは白(0)とする
// (-1,-1)から(8,8)を10行10列の行列で表したものを拡張ドット絵行列と呼ぶ
// 拡張ドット絵行列において、隣り合う要素の値が異なるペアの個数を、そのドット絵の境界線の長さという

// ややこしい部分
// ドットに対する座標とドットが持つ頂点の座標が一致していないこと
// ドット(i,j)は4点(i,j), (i+1,j), (i+1,j+1), (i,j+1) を結んでできる正方形
// 辺(i,j)(i+1,j)などを持つ

// 辺 e = {(i,j), (i+1,j)}
// において、ドット(i,j)とドット(i,j-1)の色が異なるとき辺eを境界辺という
// 同様に辺e={(i,j),(i,j+1)}において、ドット(i,j)とドット(i-1,j)の色が異なるとき、辺eを境界辺という

// ドット絵の境界辺をすべて集めて作られるグラフをそのドット絵の境界グラフと呼ぶ
// 境界グラフの連結成分の個数が1以下のとき連結なドット絵といい
// 境界グラフの連結成分の個数が2以上のときは非連結なドット絵という
// また、次数2の頂点のみからなる境界グラフをもつドット絵を強連結といい
// 次数4の頂点を持つ連結なドット絵を弱連結なドット絵という
// 境界グラフは8×8グリッドグラフの部分グラフとなっている
// 同じ辺や頂点を2度通ってもよいので、境界グラフの各辺に対応するグリッドグラフ上のすべての辺を通る最短の閉路をすべて求めたい

// ひとまず、閉路の長さだけを求める

// 境界辺集合と橋集合を定義する
// 橋は連結成分を結ぶ役割を持つ辺である
// 橋全体と橋を構成する辺を区別して呼ぶほうがよいか？

#include <iostream>

using namespace std;

int main(void) { return 0; }